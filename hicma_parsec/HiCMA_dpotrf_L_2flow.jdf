extern "C" %{
/**
 * @copyright (c) 2021     King Abdullah University of Science and Technology (KAUST).
 * @copyright (c) 2021     The Universiy of Tennessee and The Universiy of Tennessee Research Foundation.
 *                         All rights reserved.
 * @version 0.1.0
 * @date 2021-01-24
 *
 **/

#include "hicma_parsec.h"

/* Used for operation count */
extern unsigned long *op_band, *op_offband, *op_path, *op_offpath;

/*
 * Priorities used in this jdf:
 *      - potrf_dpotrf(k)    : (MT-k)**3
 *      - potrf_dsyrk(k,m)   : (MT-m)**3 + 3 * (m - k)
 *      - potrf_dtrsm(m,k)   : (MT-m)**3 + 3 * (m - k) * (2 * MT - k - m - 1)
 *      - potrf_dgemm(m,n,k) : (MT-m)**3 + 3 * (m - n) * (2 * MT - m - n - 1) + 6 * (m - k)
 *
 * So max priority is:
 *      (MT - PRI_CHANGE)**3 + 3 * MT * (2 * MT - PRI_CHANGE - 1) + 6 * MT  < (MT**3 + 6 MT**2 + 3 MT)
 *
 * WARNING: If mt is greater than 1200, we might get integer overflow.
 */

/* Count operations */
#define LOG_OPCOUNT(cnt, i, j) \
    do{\
        int myrank = es->virtual_process->parsec_context->my_rank; \
        int nth = es->virtual_process->nb_cores;\
        if(0) printf("%s rank:%d th_id:%d nthreads per node:%d\n", __func__, myrank, es->th_id, nth);\
        int myid = es->th_id;\
        opcounters[myrank*nth+myid] += cnt;  \
        tileopcounters[i*descA->nt+j] += cnt; \
    }while(0);
%}

/* Globals
 */
uplo         [ type = int ]
descA        [ type = "parsec_tiled_matrix_dc_t*" ]
descAr       [ type = "parsec_tiled_matrix_dc_t*" ]
descRank     [ type = "parsec_tiled_matrix_dc_t*" aligned = descA ]
INFO         [ type = "int*" ]
acc          [ type = "double" ]
rk           [ type = "int" ]
storage_maxrank        [ type = "int" ]
computation_maxrank    [ type = "int" ]
lookahead    [ type = "int" ]
band_size    [ type = "int" ]

/* Hidden Globals
 */
/* Memory pool handler */
p_work       [ type = "parsec_memory_pool_t *" hidden = on default = NULL ] 
p_work_rr    [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]
p_work_mbr   [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]

/* Priority */
PRI_CHANGE   [ type = "int" hidden = on default = 0 ]
PRI_MAX      [ type = "int" hidden = on default = "(descA->mt * ( 3 + descA->mt * ( 2 + descA->mt )))" ]

/* Subtile size in recursive */
smallnb      [ type = "int" hidden = on default = 300 ]

/* Whethre execute kernel */
enable_potrf [ type = "int" hidden = on default = 1 ]
enable_trsm  [ type = "int" hidden = on default = 1 ]
enable_syrk  [ type = "int" hidden = on default = 1 ]
enable_gemm  [ type = "int" hidden = on default = 1 ]

/* Whether send full tile */
send_full_tile       [ type = "int" hidden = on default = 0 ]

/* Tile and operation count */
tileopcounters       [ type = "unsigned long*" hidden = on default = NULL ]
opcounters           [ type = "unsigned long*" hidden = on default = NULL ]

/* Time gathering */
potrf_time           [ type = "double*" hidden = on default = 0 ]
trsm_time            [ type = "double*" hidden = on default = 0 ]
syrk_time            [ type = "double*" hidden = on default = 0 ]
potrf_time_temp      [ type = "double*" hidden = on default = 0 ]
trsm_time_temp       [ type = "double*" hidden = on default = 0 ]
syrk_time_temp       [ type = "double*" hidden = on default = 0 ]
wrap_potrf           [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_trsm            [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_syrk            [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_gemm            [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_potrf_complete  [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_trsm_complete   [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_syrk_complete   [ type = "parsec_hook_t*" hidden = on default = NULL ]
wrap_gemm_complete   [ type = "parsec_hook_t*" hidden = on default = NULL ]


/**************************************************
 **************************************************/
READ_Cr(m, n)

m = band_size .. descA->mt-1
n = 0 .. m-band_size

:descAr(m, n)

READ Cr <- descAr(m, n)                                        [ type = AR ]
        -> (n == 0) ? Cr potrf_dtrsm(m, n)                     [ type = AR ]
        -> (n != 0) ? Cr potrf_dgemm(m, n, 0)                  [ type = AR ]

BODY
{
    if(DEBUG_INFO) printf("READ_Cr(%d, %d)\n", m, n);
}
END


/**************************************************
 **************************************************/
WRITE_Cr(m, k)

m = band_size .. descA->mt-1
k = 0 .. m-band_size

:descAr(m, k)

READ Cr <- Cr potrf_dtrsm(m, k)              [ type = AR ]
        -> descAr(m, k)                      [ type = AR ]

BODY
{
    if(DEBUG_INFO) printf("WRITE_Cr(%d, %d)\n", m, k);
}
END


/**************************************************
 *               potrf_dpotrf                     *
 **************************************************/
potrf_dpotrf(k) [high_priority = on]

// Execution space
k = 0 .. descA->mt-1

// Parallel partitioning
:descA(k, k)

// Parameters
RW T <- (k == 0) ? descA(k, k) : T potrf_dsyrk(k-1, k)   [ type = FULL ]
     -> T potrf_dtrsm(k+1..descA->lmt-1, k)              [ type = FULL ]
     -> descA(k, k)                                      [ type = FULL ]

; (k >= (descA->mt - PRI_CHANGE)) ? (descA->mt - k) * (descA->mt - k) * (descA->mt - k) : PRI_MAX

BODY [type=RECURSIVE]
{
    if(enable_potrf == 0) return PARSEC_HOOK_RETURN_DONE;
    if(DEBUG_INFO) printf("POTRF: %d\n", k);
    int tempkm = k == descA->mt-1 ? descA->m - k*descA->mb : descA->mb;
    int iinfo = 0;

    /* Operation count */
    unsigned long int cnt = op_counts('c', tempkm, 0, 0, 0);
    LOG_OPCOUNT(cnt, k, k);
    op_band[es->th_id] += cnt;
    op_path[es->th_id] += cnt;

    if( tempkm > smallnb )
    {
        subtile_desc_t *small_descT;
        parsec_taskpool_t *parsec_dpotrf;

        small_descT = subtile_desc_create( descA, k, k,
                                           smallnb, smallnb, 0, 0, tempkm, tempkm );
        small_descT->mat = T;

        parsec_dpotrf = dplasma_dpotrf_New(uplo, (parsec_tiled_matrix_dc_t *)small_descT, &iinfo );

        parsec_recursivecall(es, (parsec_task_t*)this_task,
                             parsec_dpotrf, dplasma_dpotrf_Destruct,
                             1, small_descT);

        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else
        /* Go for the sequential CPU version */
        return PARSEC_HOOK_RETURN_NEXT;
}
END

BODY
{
    if(enable_potrf == 0) return PARSEC_HOOK_RETURN_DONE;
    int tempkm = k == descA->mt-1 ? descA->m - k*descA->mb : descA->mb;
    int iinfo = 0;
    int ld_Ag_k = BLKLDD( descA, k );
    flop_counter flops;
    HCORE_dpotrf( dplasma_lapack_const(uplo), tempkm, T, ld_Ag_k, &iinfo, &flops);

    if(iinfo != 0){
        printf("%s %d: dpotrf failed with a return value of %d. uplo:%d m:%d A:%p lda:%d\n", __FILE__, __LINE__, iinfo, uplo, tempkm, T, ld_Ag_k);
        fflush(stdout);
        //exit(-1);
    }

    if ( iinfo != 0 && *INFO == 0 )
            *INFO = k*descA->mb+iinfo; /* Should return here */

}
END


/**************************************************
 *               potrf_dtrsm                      *
 **************************************************/
potrf_dtrsm(m, k) [high_priority = on]

// Execution space
m = 1 .. descA->mt-1
k = 0 .. m-1

// Control message size to send, it's the new Cr
size = 1

// Parallel partitioning
: descA(m, k)

// Parameters
READ  T <- T potrf_dpotrf(k)                                                 [ type = FULL ]

RW    C <- (k == 0 && m-k < band_size) ? descA(m, k)                         [ type = FULL ]
        <- (k == 0 && m-k >= band_size) ? descA(m, k)                        [ type = UV ]
        <- (m-k < band_size) ? C potrf_dgemm(m, k, k-1)                      [ type = FULL ]
        <- C potrf_dgemm(m, k, k-1)                                          [ type = UV ]
        -> (m-k < band_size) ? A potrf_dsyrk(k, m)                           [ type = FULL ]
        -> (m-k < band_size) ? A potrf_dgemm(m, k+1..m-1, k)                 [ type = FULL ]
        -> (m-k < band_size) ? B potrf_dgemm(m+1..descA->lmt-1, m, k)        [ type = FULL ]
        -> (m-k < band_size) ? descA(m, k)                                   [ type = FULL ]
        -> (m-k >= band_size) ? A potrf_dsyrk(k, m)                          [ layout = parsec_datatype_double_t count = size ]
        -> (m-k >= band_size) ? A potrf_dgemm(m, k+1..m-1, k)                [ layout = parsec_datatype_double_t count = size ]
        -> (m-k >= band_size) ? B potrf_dgemm(m+1..descA->mt-1, m, k)        [ layout = parsec_datatype_double_t count = size ]
        -> (m-k >= band_size) ? descA(m, k)                                  [ layout = parsec_datatype_double_t count = size ]

READ  Cr <- (k == 0 && m-k >= band_size) ? Cr READ_Cr(m, k)                  [ type = AR ]
         <- (k != 0 && m-k >= band_size) ? Cr potrf_dgemm(m, k, k-1): NULL   [ type = AR ]
         -> (m-k >= band_size) ? Ar potrf_dsyrk(k, m)                        [ type = AR ] 
         -> (m-k >= band_size) ? Ar potrf_dgemm(m, k+1..m-1, k)              [ type = AR ] 
         -> (m-k >= band_size) ? Br potrf_dgemm(m+1..descA->mt-1, m, k)      [ type = AR ] 
         -> (m-k >= band_size) ? Cr WRITE_Cr(m, k)                           [ type = AR ] 

CTL ctl <- (lookahead == 1 && m > lookahead+k)? ctl potrf_dsyrk(k, k+1)
CTL ctl1 <- (lookahead > 1 && m > lookahead+k)? ctl2 potrf_dtrsm(k+2, k)
CTL ctl2 -> (lookahead > 1 && m == k+2)? ctl1 potrf_dtrsm(lookahead+k+1 .. descA->mt-1, k)

; (m >= (descA->mt - PRI_CHANGE)) ? (descA->mt - m) * (descA->mt - m) * (descA->mt - m) + 3 * ((2 * descA->mt) - k - m - 1) * (m - k) : PRI_MAX

BODY [type=RECURSIVE]
{
    if(enable_trsm == 0) return PARSEC_HOOK_RETURN_DONE;
    int tempmm = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;

    /* Operation count */
    if( m-k < band_size ) { 
        unsigned long int cnt = op_counts('t', tempmm, tempmm, 1 /*side*/, 0);
        LOG_OPCOUNT(cnt, m, k);
        op_band[es->th_id] += cnt;
        if( 1 == m-k )
            op_path[es->th_id] += cnt;
        else
            op_offpath[es->th_id] += cnt;
    } else {
        unsigned long int cnt = op_counts('t', tempmm, ((int*)Cr)[0], 1 /*side*/, 0);
        LOG_OPCOUNT(cnt, m, k);
        op_offband[es->th_id] += cnt;
        if( 1 == m-k )
            op_path[es->th_id] += cnt;
        else
            op_offpath[es->th_id] += cnt;
    }

    if ( (m-k < band_size) && (tempmm > smallnb) )
    {
        if(DEBUG_INFO) printf("TRSM Recursive: %d %d ; mb %d, nb: %d, band_size: %d\n", m, k, descA->mb, descA->nb, band_size);
        subtile_desc_t *small_descT;
        subtile_desc_t *small_descC;
        parsec_taskpool_t* parsec_dtrsm;

        small_descT = subtile_desc_create( descA, k, k,
                                           smallnb, smallnb, 0, 0, descA->mb, descA->mb );
        small_descT->mat = T;

        small_descC = subtile_desc_create( descA, m, k,
                                           smallnb, smallnb, 0, 0, tempmm, descA->mb );
        small_descC->mat = C;

        parsec_dtrsm = dplasma_dtrsm_New(dplasmaRight, dplasmaLower,
                                        dplasmaTrans, dplasmaNonUnit,
                                        (double)1.0,
                                        (parsec_tiled_matrix_dc_t *)small_descT,
                                        (parsec_tiled_matrix_dc_t *)small_descC );

        parsec_recursivecall(es, (parsec_task_t*)this_task,
                             parsec_dtrsm, dplasma_dtrsm_Destruct,
                             2, small_descT, small_descC );

        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else
        /* Go for the sequential CPU version */
        return PARSEC_HOOK_RETURN_NEXT;
}
END

BODY
{
#if PRINT_RANK
    /* Gather rank */
    if( 0 == k && m-k >= band_size && descRank->super.myrank == descRank->super.rank_of(&descRank->super, m, k) ) {
        /* New data_copy and allocate memory for descRank(m, n) */
        parsec_data_copy_t *my_data_copy = parsec_data_copy_new(descRank->super.data_of(&descRank->super, m, k), 0);
        my_data_copy->device_private = calloc(RANK_MAP_BUFF, sizeof(int));

        ((int *)((descRank->super.data_of(&descRank->super, m, k))->device_copies[0]->device_private))[0] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, k))->device_copies[0]->device_private))[1] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, k))->device_copies[0]->device_private))[2] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, k))->device_copies[0]->device_private))[3] = ((int *)Cr)[0];
    }
#endif

    if(enable_trsm == 0) return PARSEC_HOOK_RETURN_DONE;
    if( m-k < band_size ) {
        int tempmm = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int ldak = BLKLDD( descA, k );
        int ldam = BLKLDD( descA, m );

        CORE_dtrsm(dplasmaRight, dplasmaLower, dplasmaTrans, dplasmaNonUnit,
                   tempmm, descA->mb,
                   (double)1.0, T /*A(k, k)*/, ldak,
                                           C /*A(m, k)*/, ldam);

    } else {
        /* If rank is 0, return and set communication count to 0 */
        if( 0 == *((int *)Cr) ) {
            this_task->locals.size.value = 0;
            return PARSEC_HOOK_RETURN_DONE;
        }

        int tempmm = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int ldak = BLKLDD( descA, k );
        int ldam = BLKLDD( descA, m );
        void *Cv = (void *)C + descA->mb * ((int *)Cr)[0] * sizeof(double);

        flop_counter flops;
        int Crank = *((int *)Cr);
        HCORE_dtrsm(dplasmaLeft, dplasmaLower, dplasmaNoTrans, dplasmaNonUnit,
                tempmm, Crank, (double)1.0, T, ldak, Cv, ldam, &flops  );

        /* Pass Cr value to size */
        if(send_full_tile == 1){
            this_task->locals.size.value = descA->mb * storage_maxrank * 2;
        } else {
            this_task->locals.size.value = descA->mb * ((int *)Cr)[0] * 2;
        }

        if(DEBUG_INFO) printf("Cr value in DTRSM (%d, %d): %d\n", m, k, ((int *)Cr)[0]);
    }
}
END


/**************************************************
 *               potrf_dsyrk                      *
 **************************************************/
potrf_dsyrk(k, m) [high_priority = on]

// Execution space
k = 0   .. descA->mt-2
m = k+1 .. descA->mt-1

// Parallel partitioning
: descA(m, m)

//Parameters
READ  A <- (m-k < band_size) ? C potrf_dtrsm(m, k)                      [ type = FULL ]
        <- C potrf_dtrsm(m, k)                                          [ type = UV ]

READ  Ar <- (m-k >= band_size) ? Cr potrf_dtrsm(m, k): NULL             [ type = AR ]

RW    T <- (k == 0) ? descA(m, m) : T potrf_dsyrk(k-1, m)               [ type = FULL ] 
        -> (m == k+1) ? T potrf_dpotrf(m) : T potrf_dsyrk(k+1, m)       [ type = FULL ]

CTL ctl -> (lookahead == 1 && m == k+1)? ctl potrf_dtrsm(lookahead+m .. descA->mt-1, k)

; (m >= (descA->mt - PRI_CHANGE)) ? (descA->mt - m) * (descA->mt - m) * (descA->mt - m) + 3 * (m - k) : PRI_MAX


BODY [type=RECURSIVE]
{
    if(enable_syrk == 0) return PARSEC_HOOK_RETURN_DONE;
    int tempmm = m == descA->mt-1 ? descA->m - m*descA->mb : descA->mb;

    /* Operation count */
    if( m-k < band_size ) {
        unsigned long int cnt = op_counts('m', tempmm, tempmm, tempmm, 0);
        LOG_OPCOUNT(cnt, m, m);
        op_band[es->th_id] += cnt;
        if( 1 == m-k )
            op_path[es->th_id] += cnt;
        else
            op_offpath[es->th_id] += cnt;
    } else {
        int rank = ((int*)Ar)[0];
        /// C = C + alpha * A * A'
        /// C = C + alpha * ( (A^u * (A^v * A^v^T) ) * A^u^T)
        unsigned long int cnt = 0;
        /// A^v * B^v^T
        cnt += op_counts('m', rank, rank, tempmm, 0);
        /// A^u * (A^v * B^v^T)
        cnt += op_counts('m', tempmm, rank, rank, 0);
        /// (A^u * (A^v * B^v^T) ) * B^u^T
        cnt += op_counts('m', tempmm, tempmm, rank, 0);
        LOG_OPCOUNT(cnt, m, m);
        op_band[es->th_id] += cnt;
        if( 1 == m-k )
            op_path[es->th_id] += cnt;
        else
            op_offpath[es->th_id] += cnt;
    }

    /* If recursive */
    if ( (m-k < band_size) && (tempmm > smallnb) )
    {
        if(DEBUG_INFO) printf("SYRK Recursive %d %d \n", k, m);
        subtile_desc_t *small_descT;
        subtile_desc_t *small_descA;
        parsec_taskpool_t* parsec_dsyrk;

        small_descT = subtile_desc_create( descA, m, m,
                                           smallnb, smallnb, 0, 0, tempmm, tempmm );
        small_descT->mat = T;

        small_descA = subtile_desc_create( descA, m, k,
                                           smallnb, smallnb, 0, 0, tempmm, descA->mb );
        small_descA->mat = A;

        parsec_dsyrk = dplasma_dsyrk_New( dplasmaLower, dplasmaNoTrans,
                                         (double)-1.0, (parsec_tiled_matrix_dc_t*) small_descA,
                                         (double)1.0,  (parsec_tiled_matrix_dc_t*) small_descT);

        parsec_recursivecall(es, (parsec_task_t*)this_task,
                             parsec_dsyrk, dplasma_dsyrk_Destruct,
                             2, small_descA, small_descT);
        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else
        /* Go for the sequential CPU version */
        return PARSEC_HOOK_RETURN_NEXT;
}
END

BODY
{
    if(enable_syrk == 0) return PARSEC_HOOK_RETURN_DONE;
    int tempmm = m == descA->mt-1 ? descA->m - m*descA->mb : descA->mb;
    int ldam = BLKLDD( descA, m );

    /* No recursive, dense SYRK or low rank LR_SYRK */
    if( m-k < band_size ) {
        CORE_dsyrk(dplasmaLower, dplasmaNoTrans,
                   tempmm, descA->mb,
                   (double)-1.0, A /*A(m, k)*/, ldam,
                   (double) 1.0, T /*A(m, m)*/, ldam);

    } else {
        /* If rank is 0, return */
        if( 0 == *((int *)Ar) ) {
            return PARSEC_HOOK_RETURN_DONE;
        }

        int ldau = BLKLDD( descA, m );
        int ldav = BLKLDD( descA, m );
        int rank = ((int*)Ar)[0];
        void *Au = (void *)A;
        void *Av = (void *)A + descA->mb * rank * sizeof(double);
        int call_hcore_dsyrk = 1;

#define call_hcore_dsyrk 1

#if call_hcore_dsyrk
        void *p_elem_work = parsec_private_memory_pop( p_work );
        flop_counter flops;
        HCORE_dsyrk(dplasmaLower, dplasmaNoTrans,
                   tempmm, rank,
                   (double)-1.0, 
                   Au /*A(m, k)*/, ldau,
                   Av /*A(m, k)*/, ldav,
                   (double) 1.0, T /*A(m, m)*/, ldam, p_elem_work, &flops);
        parsec_private_memory_push( p_work, p_elem_work );

/* If want to call 3 gemms instead */
#else
        void *p_elem_work_mbr = parsec_private_memory_pop( p_work_mbr );
        void *p_elem_work_rr = parsec_private_memory_pop( p_work_rr );

        /* tmp_rr = trans(Av) * Av */
        CORE_dgemm(dplasmaTrans, dplasmaNoTrans,
                   rank, rank, descA->mb,
                   (double) 1.0, Av             /*A(k, m)*/, descA->mb,
                                 Av             /*A(k, n)*/, descA->mb,
                   (double) 0.0, p_elem_work_rr /*A(m, n)*/, rank);

        /* tmp_mbr = tmp_rr * trans(Au) */
        CORE_dgemm(dplasmaNoTrans, dplasmaTrans,
                   rank, descA->mb, rank,
                   (double) 1.0, p_elem_work_rr  /*A(m, k)*/, rank,
                                 Au              /*A(n, k)*/, descA->mb,
                   (double) 0.0, p_elem_work_mbr /*A(m, n)*/, rank);

        /* T = T - Au * tmp_mbr */
        CORE_dgemm(dplasmaNoTrans, dplasmaNoTrans,
                   descA->mb, descA->mb, rank,
                   (double)-1.0, Au              /*A(m, k)*/, descA->mb,
                                 p_elem_work_mbr /*A(k, n)*/, rank,
                   (double) 1.0, T               /*A(m, n)*/, descA->mb);

        parsec_private_memory_push( p_work_mbr, p_elem_work_mbr );
        parsec_private_memory_push( p_work_rr, p_elem_work_rr );
#endif

    }
}
END

/**************************************************
 *               potrf_dgemm                      *
 **************************************************/
// Name
potrf_dgemm(m, n, k)

// Execution space
k = 0   .. descA->mt-3
m = k+2 .. descA->mt-1
n = k+1 .. m-1

// Control message size to send, it's the new Cr
size = 1

// Parallel partitioning
: descA(m, n)

// Parameters
READ   A <- (m-k < band_size) ? C potrf_dtrsm(m, k)                                    [ type = FULL ] 
         <- C potrf_dtrsm(m, k)                                                        [ type = UV ] 

READ  Ar <- (m-k >= band_size) ? Cr potrf_dtrsm(m, k): NULL                            [ type = AR ]

READ   B <- (n-k < band_size) ? C potrf_dtrsm(n, k)                                    [ type = FULL ] 
         <- C potrf_dtrsm(n, k)                                                        [ type = UV ]

READ  Br <- (n-k >= band_size) ? Cr potrf_dtrsm(n, k): NULL                            [ type = AR ]

RW     C <- (k == 0 && m-n < band_size) ? descA(m, n)                                  [ type = FULL ]
         <- (k == 0 && m-n >= band_size) ? descA(m, n)                                 [ type = UV ]
         <- (m-n < band_size) ? C potrf_dgemm(m, n, k-1)                               [ type = FULL ]
         <- C potrf_dgemm(m, n, k-1)                                                   [ type = UV ]
         -> (n == k+1 && m-n < band_size) ? C potrf_dtrsm(m, n)                        [ type = FULL ]
         -> (n != k+1 && m-n < band_size) ? C potrf_dgemm(m, n, k+1)                   [ type = FULL ]
         -> (n == k+1 && m-n >= band_size) ? C potrf_dtrsm(m, n)                       [ layout = parsec_datatype_double_t count = size ]
         -> (n != k+1 && m-n >= band_size) ? C potrf_dgemm(m, n, k+1)                  [ layout = parsec_datatype_double_t count = size ]

RW    Cr <- (k == 0 && m-n >= band_size) ? Cr READ_Cr(m, n)                            [ type = AR ]
         <- (k != 0 && m-n >= band_size) ? Cr potrf_dgemm(m, n, k-1): NULL             [ type = AR ]
         -> (n == k+1 && m-n >= band_size) ? Cr potrf_dtrsm(m, n)                      [ type = AR ]
         -> (n != k+1 && m-n >= band_size) ? Cr potrf_dgemm(m, n, k+1)                 [ type = AR ]

; (m >= (descA->mt - PRI_CHANGE)) ? (descA->mt - m) * (descA->mt - m) * (descA->mt - m) + 3 * ((2 * descA->mt) - m - n - 3) * (m - n) + 6 * (m - k) : PRI_MAX


BODY [type=RECURSIVE]
{
    int tempmm = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;

    /* Operation count on band*/
    if ( m-k < band_size ) {
        unsigned long int cnt = op_counts('m', tempmm, tempmm, tempmm, 0);
        LOG_OPCOUNT(cnt, m, n);
        op_band[es->th_id] += cnt;
        op_offpath[es->th_id] += cnt;
    } else if( n-k < band_size && m-n < band_size ) {
        int Arank = ((int*)Ar)[0];
        unsigned long int cnt = op_counts('m', tempmm, tempmm, Arank, 0) * 2;
        LOG_OPCOUNT(cnt, m, n);
        op_band[es->th_id] += cnt;
        op_offpath[es->th_id] += cnt;
    } else if( m-n < band_size ) {
        int Arank = ((int*)Ar)[0];
        int Brank = ((int*)Br)[0];
        unsigned long int cnt = op_counts('m', tempmm, tempmm, parsec_imin(Arank, Brank), 0)
                                + op_counts('m', tempmm, Arank, Brank, 0) * 2;
        LOG_OPCOUNT(cnt, m, n);
        op_band[es->th_id] += cnt;
        op_offpath[es->th_id] += cnt;
    }

    if ( (m-k < band_size) && (tempmm > smallnb) )
    {
        if(DEBUG_INFO) printf("GEMM Recursive: %d %d %d\n", m, n, k);
        subtile_desc_t *small_descA;
        subtile_desc_t *small_descB;
        subtile_desc_t *small_descC;
        parsec_taskpool_t *parsec_dgemm;

        small_descA = subtile_desc_create( descA, m, k,
                                           smallnb, smallnb, 0, 0, tempmm, descA->mb );
        small_descA->mat = A;

        small_descB = subtile_desc_create( descA, n, k,
                                           smallnb, smallnb, 0, 0, descA->mb, descA->mb );
        small_descB->mat = B;

        small_descC = subtile_desc_create( descA, m, n,
                                           smallnb, smallnb, 0, 0, tempmm, descA->mb );
        small_descC->mat = C;

        parsec_dgemm = dplasma_dgemm_New(dplasmaNoTrans, dplasmaTrans,
                                        (double)-1.0,
                                        (parsec_tiled_matrix_dc_t *)small_descA,
                                        (parsec_tiled_matrix_dc_t *)small_descB,
                                        (double) 1.0,
                                        (parsec_tiled_matrix_dc_t *)small_descC);

        parsec_recursivecall(es, (parsec_task_t*)this_task,
                             parsec_dgemm, dplasma_dgemm_Destruct,
                             3, small_descA, small_descB, small_descC );

        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else
        /* Go to CPU sequential kernel */
        return PARSEC_HOOK_RETURN_NEXT;
}
END

BODY
{
#if PRINT_RANK 
    /* Gather rank */
    if( m-n >= band_size && descRank->super.myrank == descRank->super.rank_of(&descRank->super, m, n) && 0 == k ) {
        /* New data_copy and allocate memory for descRank(m, n) */
        parsec_data_copy_t *my_data_copy = parsec_data_copy_new(descRank->super.data_of(&descRank->super, m, n), 0);
        my_data_copy->device_private = calloc(RANK_MAP_BUFF, sizeof(int));

        ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[0] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[1] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[2] = ((int *)Cr)[0];
        ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[3] = ((int *)Cr)[0];
    } 
#endif

    if(enable_gemm == 0) return PARSEC_HOOK_RETURN_DONE;
    if(DEBUG_INFO) printf("GEMM (%d, %d, %d)\n", m, n, k);

    /* No recursive */
    if ( m-k < band_size ) {
        int tempmm = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int ldam = BLKLDD( descA, m );
        int ldan = BLKLDD( descA, n );

        CORE_dgemm(dplasmaNoTrans, dplasmaTrans,
                   tempmm, descA->mb, descA->mb,
                   (double)-1.0, A /*A(m, k)*/, ldam,
                                 B /*A(n, k)*/, ldan,
                   (double) 1.0, C /*A(m, n)*/, ldam);

    } else if( n-k < band_size && m-n < band_size ) {
        void *p_elem_work_mbr = parsec_private_memory_pop( p_work_mbr );
        int Arank = ((int *)Ar)[0];
        void *Au = (void *)A;
        void *Av = (void *)A + descA->mb * Arank * sizeof(double);

        /* tmp_mbr = trans(Av) * trans(B) */
        CORE_dgemm(dplasmaTrans, dplasmaTrans,
                   Arank, descA->mb, descA->mb,
                   (double)1.0, Av /*A(m, k)*/, descA->mb,
                                 B /*A(n, m)*/, descA->mb,
                   (double) 0.0, p_elem_work_mbr /*A(k, n)*/, Arank);

        /* C = C - Au * tmp_mbr */ 
        CORE_dgemm(dplasmaNoTrans, dplasmaNoTrans,
                   descA->mb, descA->mb, Arank,
                   (double)-1.0, Au              /*A(m, k)*/, descA->mb,
                                 p_elem_work_mbr /*A(k, n)*/, Arank,
                   (double) 1.0, C               /*A(m, n)*/, descA->mb);

        parsec_private_memory_push( p_work_mbr, p_elem_work_mbr );

    } else if( m-n < band_size ) {
        void *p_elem_work_mbr = parsec_private_memory_pop( p_work_mbr );
        void *p_elem_work_rr = parsec_private_memory_pop( p_work_rr );
        int Arank = ((int *)Ar)[0];
        int Brank = ((int *)Br)[0];

        void *Au = (void *)A;
        void *Av = (void *)A + descA->mb * Arank * sizeof(double);

        void *Bu = (void *)B;
        void *Bv = (void *)B + descA->mb * Brank * sizeof(double);

        /* tmp_rr = trans(Av) * Bv */
        CORE_dgemm(dplasmaTrans, dplasmaNoTrans,
                   Arank, Brank, descA->mb,
                   (double) 1.0, Av             /*A(k, m)*/, descA->mb,
                                 Bv             /*A(k, n)*/, descA->mb,
                   (double) 0.0, p_elem_work_rr /*A(m, n)*/, Arank);

        if( Arank > Brank ) {
            /* tmp_mbr = Au * tmp_rr */
            CORE_dgemm(dplasmaNoTrans, dplasmaNoTrans,
                       descA->mb, Brank, Arank,
                       (double) 1.0, Au              /*A(m, k)*/, descA->mb,
                                     p_elem_work_rr  /*A(k, n)*/, Arank,
                       (double) 0.0, p_elem_work_mbr /*A(m, n)*/, descA->mb);

            /* C = C - tmp_mbr * trans(Bu) */
            CORE_dgemm(dplasmaNoTrans, dplasmaTrans,
                       descA->mb, descA->mb, Brank,
                       (double)-1.0, p_elem_work_mbr /*A(m, k)*/, descA->mb,
                                     Bu              /*A(n, k)*/, descA->mb,
                       (double) 1.0, C               /*A(m, n)*/, descA->mb);
        } else {
            /* tmp_mbr = tmp_rr * trans(Bu) */
            CORE_dgemm(dplasmaNoTrans, dplasmaTrans,
                       Arank, descA->mb, Brank,
                       (double) 1.0, p_elem_work_rr  /*A(m, k)*/, Arank,
                                     Bu              /*A(n, k)*/, descA->mb,
                       (double) 0.0, p_elem_work_mbr /*A(m, n)*/, Arank);

            /* C = C - Au * tmp_mbr */
            CORE_dgemm(dplasmaNoTrans, dplasmaNoTrans,
                       descA->mb, descA->mb, Arank,
                       (double)-1.0, Au              /*A(m, k)*/, descA->mb,
                                     p_elem_work_mbr /*A(k, n)*/, Arank,
                       (double) 1.0, C               /*A(m, n)*/, descA->mb);
        }

        parsec_private_memory_push( p_work_mbr, p_elem_work_mbr );
        parsec_private_memory_push( p_work_rr, p_elem_work_rr );

    } else if( n-k < band_size && m-n >= band_size ) {
        int tempmmu = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int tempmmv = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int ldamu = BLKLDD( descA, m );
        int ldamv = BLKLDD( descA, m );
        int ldanu = BLKLDD( descA, n );
        int ldanv = BLKLDD( descA, n );

        int Arank = ((int*)Ar)[0];
        int Crank_old = ((int*)Cr)[0];

        void *Au = (void *)A;
        void *Av = (void *)A + descA->mb * Arank * sizeof(double);// FIXME descA->mb might cause problem for cleanup tiles

        void *Cu = (void *)C;
        void *Cv = (void *)C + descA->mb * Crank_old * sizeof(double);// FIXME descA->mb might cause problem for cleanup tiles

        void *p_elem_work = NULL;
        p_elem_work = parsec_private_memory_pop( p_work );
        int new_Crank = ((int*)Cr)[0];

        /** Calls two-step hcore_gemm.
            First step reveals ACTUAL_RANK.
            Second step constructs new CU and CV.
            Provided CU and CV buffers must have at least ACTUAL_RANK number of columns.
        */
        double* work_new;
        double* _CU;
        double* _CV;
        int CU_ncols;
        int new_UVrk;
        double* newU;
        int ld_newU;
        double* qrtauA;
        int CV_ncols;
        double* newV;
        int ld_newV;
        double* qrtauB;
        int use_CUV_clone;
        double* CUclone;
        int ld_CUclone;
        double *_CU_save;
        double* CVclone;
        int ld_CVclone;
        double* _CV_save;
        flop_counter flops;
        HCORE_dgemm_qr_svd_b_dense( dplasmaNoTrans, dplasmaTrans,
                tempmmv, // ASSUMPTION: For a tile, if nrows<ncols, storage is ncols for both U and V
                tempmmv,
                (double)-1.0,
                Au, Av, Ar, ldamu,
                B, ldamv,
                (double)1.0,
                Cu, Cv, &new_Crank, ldamu,
                rk, storage_maxrank, computation_maxrank, acc, p_elem_work,
                &flops,
                /** parameters that will be passed to HCORE_dgemm_ormqr */
                &work_new,
                &_CU,
                &_CV,
                &CU_ncols,
                &new_UVrk,
                &newU,
                &ld_newU,
                &qrtauA,
                &CV_ncols,
                &newV,
                &ld_newV,
                &qrtauB,
                &use_CUV_clone,
                &CUclone,
                &ld_CUclone,
                &_CU_save,
                &CVclone,
                &ld_CVclone,
                &_CV_save
                    );

        /* If new_UVrk > Crank_old, re-allocate */
        if( new_UVrk > Crank_old && !send_full_tile ) {
            if( DEBUG_INFO ) printf("Reallocate %d %d %d\n", m, n, k);
            if( NULL != this_task->data._f_C.data_out->device_private )
                free( this_task->data._f_C.data_out->device_private ); 
            this_task->data._f_C.data_out->device_private = calloc( descA->mb * new_UVrk * 2, sizeof(double) );
            this_task->data._f_C.data_out->original->nb_elts = descA->mb * new_UVrk * 2 * sizeof(double);
        }

        /* Address for Cu and Cv to be copied to */
        _CU_save = this_task->data._f_C.data_out->device_private;
        _CV_save = this_task->data._f_C.data_out->device_private + descA->mb * new_UVrk * sizeof(double);

        HCORE_dgemm_ormqr( dplasmaNoTrans, dplasmaTrans,
                tempmmv, // ASSUMPTION: For a tile, if nrows<ncols, storage is ncols for both U and V
                tempmmv,
                (double)-1.0,
                Au, Av, Ar, ldamu,
                (double)1.0,
                Cu, Cv, &new_Crank, ldamu,
                rk, 2*storage_maxrank, computation_maxrank, acc, work_new,
                &flops,
                /** parameters coming from HCORE_dgemm_qr_svd */
                _CU,
                _CV,
                CU_ncols,
                new_UVrk,
                newU,
                ld_newU,
                qrtauA,
                CV_ncols,
                newV,
                ld_newV,
                qrtauB,
                use_CUV_clone,
                CUclone,
                ld_CUclone,
                _CU_save,
                CVclone,
                ld_CVclone,
                _CV_save
                    );

        ((int*)Cr)[0] = new_Crank;
        parsec_private_memory_push( p_work, p_elem_work );

        /* Operation count */
        int Crank_old__Arank = Crank_old + Arank;
        unsigned long int cnt = 0;

        /// QR([CU AU])
        unsigned long int qraflop = op_counts('q', tempmmv, Crank_old__Arank, 0, 0);///ASSUMPTION:tempmmv is not totally correct if nrowsC<ncolsC
        unsigned long int qrbflop = op_counts('q', tempmmv, Crank_old__Arank, 0, 0);
        /// Au * B
        qrbflop += op_counts('m', Arank, tempmmv, tempmmv, 0);
        int rA_nrows  = tempmmv < Crank_old__Arank ? tempmmv : Crank_old__Arank;
        unsigned long int svdflop = op_counts('r', Crank_old__Arank, Crank_old__Arank, 2, 0);// trmm is used
        svdflop += op_counts('s', Crank_old__Arank, 0, 0, 0);
        svdflop += Crank_old__Arank * new_Crank;
        unsigned long int newuflop = op_counts('o', tempmmv, new_Crank, Crank_old__Arank, 1);
        unsigned long int newvflop = op_counts('o', new_Crank, tempmmv, Crank_old__Arank, 2);

        cnt = qraflop + qrbflop + svdflop + newuflop + newvflop;
        LOG_OPCOUNT(cnt, m, n);
        op_offband[es->th_id] += cnt;
        op_offpath[es->th_id] += cnt;

    } else {

        /* If rank is 0, return */
        if( 0 == *((int *)Ar) || 0 == *((int *)Br) ) {
            this_task->locals.size.value = ((int *)Cr)[0] * descA->mb;
            return PARSEC_HOOK_RETURN_DONE;
        }

        int tempmmu = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int tempmmv = m == descA->mt-1 ? descA->m - m * descA->mb : descA->mb;
        int ldamu = BLKLDD( descA, m );
        int ldamv = BLKLDD( descA, m );
        int ldanu = BLKLDD( descA, n );
        int ldanv = BLKLDD( descA, n );

        int Arank = ((int*)Ar)[0];
        int Brank = ((int*)Br)[0];
        int Crank_old = ((int*)Cr)[0];

        void *Au = (void *)A;
        void *Av = (void *)A + descA->mb * Arank * sizeof(double);// FIXME descA->mb might cause problem for cleanup tiles

        void *Bu = (void *)B;
        void *Bv = (void *)B + descA->mb * Brank * sizeof(double); // FIXME descA->mb might cause problem for cleanup tiles

        void *Cu = (void *)C;
        void *Cv = (void *)C + descA->mb * Crank_old * sizeof(double);// FIXME descA->mb might cause problem for cleanup tiles

        void *p_elem_work = NULL;
        p_elem_work = parsec_private_memory_pop( p_work );

        /** Calls two-step hcore_gemm.
            First step reveals ACTUAL_RANK.
            Second step constructs new CU and CV.
            Provided CU and CV buffers must have at least ACTUAL_RANK number of columns.
         */
        double* work_new;
        double* _CU;
        double* _CV;
        int CU_ncols;
        int new_UVrk;
        double* newU;
        int ld_newU;
        double* qrtauA;
        int CV_ncols;
        double* newV;
        int ld_newV;
        double* qrtauB;
        int use_CUV_clone;
        double* CUclone;
        int ld_CUclone;
        double *_CU_save;
        double* CVclone;
        int ld_CVclone;
        double* _CV_save;
        flop_counter flops;
        HCORE_dgemm_qr_svd( dplasmaNoTrans, dplasmaTrans,
                tempmmv, // ASSUMPTION: For a tile, if nrows<ncols, storage is ncols for both U and V
                tempmmv,
                (double)-1.0,
                Au, Av, Ar, ldamu,
                Bu, Bv, Br, ldamv,
                (double)1.0,
                Cu, Cv, Cr, ldamu,
                rk, storage_maxrank, computation_maxrank, acc, p_elem_work,
                &flops,
                /** parameters that will be passed to HCORE_dgemm_ormqr */
                &work_new,
                &_CU,
                &_CV,
                &CU_ncols,
                &new_UVrk,
                &newU,
                &ld_newU,
                &qrtauA,
                &CV_ncols,
                &newV,
                &ld_newV,
                &qrtauB,
                &use_CUV_clone,
                &CUclone,
                &ld_CUclone,
                &_CU_save,
                &CVclone,
                &ld_CVclone,
                &_CV_save
                    );

        /* If new_UVrk > Crank_old, re-allocate */
        if( new_UVrk > Crank_old && !send_full_tile ) {
            if( DEBUG_INFO ) printf("\nReallocate %d %d %d\n\n", m, n, k);
            if( NULL != this_task->data._f_C.data_out->device_private )
                free( this_task->data._f_C.data_out->device_private ); 
            this_task->data._f_C.data_out->device_private = calloc( descA->mb * new_UVrk * 2, sizeof(double) );
            this_task->data._f_C.data_out->original->nb_elts = descA->mb * new_UVrk * 2 * sizeof(double);
        }

        /* Address for Cu and Cv to be copied to */
        _CU_save = this_task->data._f_C.data_out->device_private;
        _CV_save = this_task->data._f_C.data_out->device_private + descA->mb * new_UVrk * sizeof(double);

        HCORE_dgemm_ormqr( dplasmaNoTrans, dplasmaTrans,
                tempmmv, // ASSUMPTION: For a tile, if nrows<ncols, storage is ncols for both U and V
                tempmmv,
                (double)-1.0,
                Au, Av, Ar, ldamu,
                (double)1.0,
                Cu, Cv, Cr, ldamu,
                rk, storage_maxrank, computation_maxrank, acc, work_new,
                &flops,
                /** parameters coming from HCORE_dgemm_qr_svd */
                _CU,
                _CV,
                CU_ncols,
                new_UVrk,
                newU,
                ld_newU,
                qrtauA,
                CV_ncols,
                newV,
			ld_newV,
			qrtauB,
			use_CUV_clone,
			CUclone,
            ld_CUclone,
            _CU_save,
            CVclone,
            ld_CVclone,
            _CV_save
                );

        Cu = _CU_save;
        Cv = _CV_save;

        /* Update new rank */
        parsec_private_memory_push( p_work, p_elem_work );
        int Crank_new = ((int*)Cr)[0];
        if(DEBUG_INFO) printf("Cr value in DGEMM (%d, %d, %d): %d\n", m, n, k, ((int *)Cr)[0]);

        /* Pass Cr value to size */
        if(send_full_tile == 1){
            this_task->locals.size.value = descA->mb * storage_maxrank * 2;
        } else {
            this_task->locals.size.value = descA->mb * ((int *)Cr)[0] * 2;
        }

        /* Operation count */
        int Crank_old__Arank = Crank_old + Arank;
        unsigned long int cnt = 0;
        /// QR([CU AU])
        unsigned long int qraflop = op_counts('q', tempmmv, Crank_old__Arank, 0, 0);///ASSUMPTION:tempmmv is not totally correct if nrowsC<ncolsC
        /// AV*BV^T
        unsigned long int qrbflop = op_counts('m', Arank, Brank, tempmmv, 0);
        /// (AV*BV^T) * BU^T
        qrbflop += op_counts('m', Arank, tempmmv, Brank, 0);
        qrbflop += op_counts('q', tempmmv, Crank_old__Arank, 0, 0);  
        int rA_nrows  = tempmmv < Crank_old__Arank ? tempmmv : Crank_old__Arank;
        unsigned long int svdflop = op_counts('r', Crank_old__Arank, Crank_old__Arank, 2, 0);// trmm is used
        svdflop += op_counts('s', Crank_old__Arank, 0, 0, 0);
        svdflop += Crank_old__Arank * Crank_new; 
        unsigned long int newuflop = op_counts('o', tempmmv, Crank_new, Crank_old__Arank, 1);  
        unsigned long int newvflop = op_counts('o', Crank_new, tempmmv, Crank_old__Arank, 2); 

        cnt = qraflop + qrbflop + svdflop + newuflop + newvflop;
        LOG_OPCOUNT(cnt, m, n);

        op_offband[es->th_id] += cnt;
        op_offpath[es->th_id] += cnt;
    }

#if PRINT_RANK 
    /* Gather rank */
    if( m-n >= band_size && descRank->super.myrank == descRank->super.rank_of(&descRank->super, m, n) ) {
        if( ((int *)Cr)[0] < ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[1] ) 
            ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[1] = ((int *)Cr)[0];

        if( ((int *)Cr)[0] > ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[2] ) 
            ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[2] = ((int *)Cr)[0];

        if( n-1 == k ) 
            ((int *)((descRank->super.data_of(&descRank->super, m, n))->device_copies[0]->device_private))[3] = ((int *)Cr)[0];
    }
#endif
}
END
