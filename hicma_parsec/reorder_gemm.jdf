extern "C" %{
/**
 * @copyright (c) 2020 King Abdullah University of Science and Technology (KAUST).
 *                     The Universiy of Tennessee and The Universiy of Tennessee Research Foundation.
 *                     All rights reserved.
 **/

#include "hicma_parsec.h"


%}
/* Reorder gemm
 * in-band, the sequential order
 * off-band, based on Arank, reorder from n_min (1) to n_max (n-reorder_gemm)
 */

descAr          [ type = "parsec_tiled_matrix_dc_t *" ]
descRG          [ type = "parsec_tiled_matrix_dc_t *" ]
Ar_copy         [ type = "int *" ]
disp            [ type = "int *" ]
nb_elem_r       [ type = "int *" ]
band_size       [ type = "int" ]
reorder_gemm    [ type = "int" ]
rows            [ type = "int" hidden = on default = "((two_dim_block_cyclic_t *)descAr)->grid.rows" ]
cols            [ type = "int" hidden = on default = "((two_dim_block_cyclic_t *)descAr)->grid.cols" ]
work_tmp        [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]

allocate(m, n)

// Execution space
m = 0 .. descRG->mt-1
n = 0 .. m

: descRG(m, n)

READ A <- NULL 

CTL ctl -> ctl1 gather_rank(m, n, 0 .. n-1)

BODY
{
    /* New data_copy and allocate memory for descRG(m, m) */
    this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descRG(m, n), 0);

    /* First n elements for predecessor, next n elements for successor */
    this_task->data._f_A.data_out->device_private = calloc( 2*n, sizeof(int) );
}
END

gather_rank(m, n, k) 

// Execution space
m = 2 .. descRG->mt-1
n = 1 .. m-1
k = 0 .. n-1

: descRG(m, n)

READ A <- descRG(m, n)

CTL ctl1 <- ctl allocate(m, n)
CTL ctl2 -> ctl reorder(m, n)

BODY
{
    if( m-n >= band_size ) {
        int Aprocs = descAr->super.rank_of(&descAr->super, m, k);
        int Bprocs = descAr->super.rank_of(&descAr->super, n, k);
        int Cprocs = descAr->super.rank_of(&descAr->super, m, n);
        int local_m = m / rows;
        int local_n_B = n / rows;
        int local_n_C = n / cols;
        int local_k = k / cols;
        int Arank = Ar_copy[disp[Aprocs] + local_k * nb_elem_r[Aprocs] + local_m];
        int Brank = Ar_copy[disp[Bprocs] + local_k * nb_elem_r[Bprocs] + local_n_B];
        int Crank = Ar_copy[disp[Cprocs] + local_n_C * nb_elem_r[Cprocs] + local_m];

        if( -1 == Arank || -1 == Brank || -1 == Crank ) {
            if( !(-1 == Brank && n-k < band_size) )
            fprintf(stderr, "ERROR in gemm_ops (%d, %d, %d): Arank %d, Brank %d, Crank %d\n", m, n, k, Arank, Brank, Crank);
        }

#if DEBUG_INFO
	printf("gather_rank_of_reorder %d %d %d: Arank %d posA %d, Brank %d posB %d, Crank %d posC %d; "
			"Anb_elem_r %d, Adisp %d, Bnb_elem_r %d, Bdisp %d, Cnb_elem_r %d, Cdisp %d; "
			"Aprocs %d, Cprocs %d, Bprocs %d, local_m %d, local_n_B %d, local_n_C %d, local_k %d\n",
			m, n, k, Arank, disp[Aprocs] + local_k * nb_elem_r[Aprocs] + local_m,
			Brank, disp[Bprocs] + local_k * nb_elem_r[Bprocs] + local_n_B,
			Crank, disp[Cprocs] + local_n_C * nb_elem_r[Cprocs] + local_m,
			nb_elem_r[Aprocs], disp[Aprocs], nb_elem_r[Bprocs], disp[Bprocs],
			nb_elem_r[Cprocs], disp[Cprocs], Aprocs, Bprocs, Cprocs,
			local_m, local_n_B, local_n_C, local_k);
#endif

        /* Policy to do re-order; be aware: B is dense if n < band_size */
        //((int *)A)[k] = Arank;
        //((int *)A)[k] = Brank;
        //((int *)A)[k] = parsec_imax(Arank, Brank);
        //((int *)A)[k] = Arank + Brank; 
        ((int *)A)[k] = parsec_imin(Arank, Brank);
    }
}
END

reorder(m, n)

// Execution space
m = 2 .. descRG->mt-1
n = 1 .. m-1

: descRG(m, n)

READ A <- descRG(m, n)

CTL ctl <- ctl2 gather_rank(m, n, 0 .. n-1)

BODY
{
    int n_min = 1, n_max = n-reorder_gemm, tmp;
    int *buff = parsec_private_memory_pop(work_tmp);

    /* Initialize to sequential order */
    for( int i = 0; i < n; i ++ )
        buff[i] = i;

#if DEBUG_INFO
    printf("actual_rank_order (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", ((int *)A)[i]);

    printf("\nlocation_before (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", buff[i]);
#endif

    if( reorder_gemm > 1 && m-n >= band_size ) {
        for( int i = n_min; i <= n_max; i++) {
            for( int j = i+1; j <= n_max; j++) {
                if( ((int *)A)[i] > ((int *)A)[j] ) {
                    tmp = buff[i];
                    buff[i] = buff[j];
                    buff[j] = tmp;
                }
            }
        }
    }

#if DEBUG_INFO
    printf("\nlocation_after (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", buff[i]);
    printf("\n\n");
#endif

    /* Set new order to descRG */
    for( int i = 0; i < n; i ++ ) {
	    /* Predecessor */
	    if( 0 == i ) 
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]] = -1;
	    else
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]] = buff[i-1];

	    /* Sucessor */
	    if( n-1 == i ) 
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]+n] = -1;
	    else
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]+n] = buff[i+1];
    }

    parsec_private_memory_push(work_tmp, buff);
}
END

extern "C" %{

parsec_taskpool_t*
parsec_reorder_gemm_New(parsec_tiled_matrix_dc_t *dcAr,
                        parsec_tiled_matrix_dc_t *dcRG,
                        int *Ar_copy, int *disp,
                        int *nb_elem_r, int band_size,
                        int reorder_gemm)
{
    parsec_taskpool_t* reorder_gemm_taskpool;
    parsec_reorder_gemm_taskpool_t* taskpool = NULL;

    taskpool = parsec_reorder_gemm_new(dcAr, dcRG, Ar_copy, disp, nb_elem_r,
                                       band_size, reorder_gemm);
    reorder_gemm_taskpool = (parsec_taskpool_t*)taskpool;

    taskpool->_g_work_tmp = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init( taskpool->_g_work_tmp, dcAr->lnt * sizeof(int) );

    parsec_matrix_add2arena(taskpool->arenas[PARSEC_reorder_gemm_DEFAULT_ARENA],
                            parsec_datatype_int_t, matrix_UpperLower,
                            1, dcRG->mb, dcRG->nb, dcRG->mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return reorder_gemm_taskpool;
}

/**
 * @param [inout] the parsec object to destroy
*/
void parsec_reorder_gemm_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_reorder_gemm_taskpool_t *reorder_gemm_taskpool = (parsec_reorder_gemm_taskpool_t *)taskpool;
    parsec_private_memory_fini( reorder_gemm_taskpool->_g_work_tmp );
    parsec_taskpool_free(taskpool);
}

int parsec_reorder_gemm(parsec_context_t *parsec,
                        parsec_tiled_matrix_dc_t *dcAr,
                        parsec_tiled_matrix_dc_t *dcRG,
                        int *Ar_copy, int *disp,
                        int *nb_elem_r, int band_size,
                        int reorder_gemm)
{
    parsec_taskpool_t *parsec_reorder_gemm = NULL;
    
    parsec_reorder_gemm = parsec_reorder_gemm_New(dcAr, dcRG, Ar_copy, disp, nb_elem_r,
                                                  band_size, reorder_gemm);

    if( parsec_reorder_gemm != NULL ){
        parsec_context_add_taskpool(parsec, parsec_reorder_gemm);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        parsec_reorder_gemm_Destruct(parsec_reorder_gemm);
    }

    return 0;
}

%}
