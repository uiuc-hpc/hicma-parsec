extern "C" %{
/**
 * @copyright (c) 2020 King Abdullah University of Science and Technology (KAUST).
 *                     The Universiy of Tennessee and The Universiy of Tennessee Research Foundation.
 *                     All rights reserved.
 **/
#include "hicma_parsec.h"

%}

/** Gather from dcAr to rank_array 
*/
descY         [ type = "parsec_tiled_matrix_dc_t *" ]
rank_array    [ type = "int *" ]
num_col       [ type = "int" hidden=on default="((two_dim_block_cyclic_t *)descY)->grid.cols * ((two_dim_block_cyclic_t *)descY)->grid.kcols" ]
NT            [ type = "int" hidden=on default="(descY->lnt-1)/num_col" ]

/**************************************************
 *                   my_task                      *
 **************************************************/
my_task(m, n, batch)

batch = 0 .. NT
m = 0 .. descY->lmt-1
n = %{ return batch*num_col; %} .. %{ return parsec_imin((batch+1)*num_col-1, m); %}

: descY(m, n)

READ Y <- descY(m, n)

CTL ctl1 <- (batch > 0)? ctl2 my_task(m, n-num_col, batch-1)
CTL ctl2 -> (batch < NT)? ctl1 my_task(m, n+num_col, batch+1)

BODY
{
    rank_array[n*descY->lmt+m] = *((int *)Y);
}
END

extern "C" %{

/**
 * @brief New function
 *
 * @param [in] Y: the data, already distributed and allocated
 * @param [in] rank_array: array of rank 
 * @return the parsec object to schedule.
 */
parsec_taskpool_t*
parsec_rank_gather_New(parsec_tiled_matrix_dc_t *Y, int *rank_array)
{
    parsec_taskpool_t* rank_gather_taskpool;
    parsec_rank_gather_taskpool_t* taskpool = NULL;

    taskpool = parsec_rank_gather_new(Y, rank_array);
    rank_gather_taskpool = (parsec_taskpool_t*)taskpool;

    parsec_matrix_add2arena(taskpool->arenas[PARSEC_rank_gather_DEFAULT_ARENA],
                            parsec_datatype_int_t, matrix_UpperLower,
                            1, 1, 1, 1,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return rank_gather_taskpool;
}

/**
 * @param [inout] the parsec object to destroy
 */
void parsec_rank_gather_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_rank_gather_taskpool_t *rank_gather_taskpool = (parsec_rank_gather_taskpool_t *)taskpool;
    parsec_matrix_del2arena(rank_gather_taskpool->arenas[PARSEC_rank_gather_DEFAULT_ARENA]);
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Gather dcY to rank_array 
 *
 * @param [in] dcY: the data, already distributed and allocated
 * @param [in] rank_array: array of rank 
 */
int parsec_rank_gather(parsec_context_t *parsec,
		parsec_tiled_matrix_dc_t *dcY,
		int *rank_array)
{
    parsec_taskpool_t *parsec_rank_gather = NULL;

    if( dcY->mb != 1 || dcY->nb != 1 ) {
        if( 0 == dcY->super.myrank )
            fprintf(stderr, "ERROR: Only gather rank in Ar\n");
        return PARSEC_ERR_BAD_PARAM;
    }
   
    /* A tempory buff to gather rank info for each process */ 
    int *rank_array_tmp = (int *)calloc(dcY->lm * dcY->ln, sizeof(int) );
    
    parsec_rank_gather = parsec_rank_gather_New( dcY, rank_array_tmp );

    parsec_context_add_taskpool(parsec, parsec_rank_gather);
    parsec_context_start(parsec);
    parsec_context_wait(parsec);
    parsec_rank_gather_Destruct(parsec_rank_gather);

    /* Call MPI_Allreduce to reduce rank_array */
    MPI_Allreduce( rank_array_tmp, rank_array, dcY->lm * dcY->ln, MPI_INT, MPI_SUM, MPI_COMM_WORLD ); 

    return 0;
}

%}
